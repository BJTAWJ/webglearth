<?xml version='1.0' encoding='UTF-8'?> 
<!DOCTYPE HTML> 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
 <head> 
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> 
  <meta name="robots" content="index, all" />
  <meta name="author" content="Petr Sloup" />
  <title>WebGL Earth - compiled</title>
  
  <style>
    .goog-slider-horizontal {
      background-color: ThreeDFace;
      position: relative;
      overflow: hidden;
    }
 
    .goog-slider-thumb {
      position: absolute;
      background-color: ThreeDShadow;
      overflow: hidden;
    }
 
    .goog-slider-horizontal .goog-slider-thumb {
      left: 0;
      width: 20px;
      height: 100%;
    }
  </style>
  <link rel="stylesheet" href="closure-library/closure/goog/css/common.css"> 
  <link rel="stylesheet" href="closure-library/closure/goog/css/menubutton.css"> 
  <link rel="stylesheet" href="closure-library/closure/goog/css/menu.css"> 
  <link rel="stylesheet" href="closure-library/closure/goog/css/menuitem.css"> 
  
  <script src="compiled.js"></script>
  
  <script id="shader-fs" type="x-shader/x-fragment"> 
    #ifdef GL_ES
    precision highp float;
    #endif
    
    varying vec2 vTextureCoord;
    
    uniform sampler2D uTileBuffer;
    
    void main(void) {
      gl_FragColor = texture2D(uTileBuffer, vTextureCoord);
    }
  </script>
   
  <script id="shader-vs" type="x-shader/x-vertex">
    #ifdef GL_ES
    precision highp float;
    #endif
    
    const float PI  = 3.1415927;
    const float PI2 = 6.2831855;
    const float PIhalf = 1.5707963;
    const float MAX_PHI = 1.4844222;
    
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    
    uniform mat4 uMVPMatrix;
    
    uniform float uZoomLevel;
    uniform float uTileCount;
    uniform float uYOffset;
    uniform float uXOffset;
        
    uniform sampler2D uTileBuffer;
    uniform vec2 uTileBufferSize;
    
    uniform vec4 uMetaBuffer[64];
    varying vec2 vTextureCoord;
    
    float compareMeta(vec4 a, float zoom, float x, float y) {
      return ((a.r == zoom) ? ((a.g == x) ? ((a.b == y) ? 0.0 : (a.b - y)) : (a.g - x)) : (a.r - zoom));
    }
    
    void main(void) {
      float phix = (aVertexPosition.x)/uTileCount*PI2;
      float phiy = (uYOffset+aVertexPosition.y)/uTileCount*PI2;
      
      //this version has better accuracy than 2.0*atan(exp(uLatitude + phiy)) - PI/2.0
      // (is more numerically stable)
      phiy = atan((exp(phiy) - exp(-phiy))/2.0);
      
      //if (abs(phiy) > MAX_PHI)
      //  phiy = sign(phiy)*PIhalf;
        
      if (abs(phix) > PI)
        phix = PI;        
      if (abs(phiy) > PI)
        phiy = PI;
      
      gl_Position = uMVPMatrix * vec4(sin(phix)*cos(phiy), sin(phiy), cos(abs(phix))*cos(abs(phiy)), 1.0);      
      
      float tilex = mod((aVertexPosition.x - aTextureCoord.x  + uXOffset + uTileCount/2.0), uTileCount);
      float tiley = (uTileCount-1.0) - (aVertexPosition.y - aTextureCoord.y + uYOffset + uTileCount/2.0);
      float xoff = 0.0, yoff = 0.0;
      
      
      int size = int(uTileBufferSize.x*uTileBufferSize.y);
      int mid = 1, min = 1, max = size;
      float z = uZoomLevel;
      while (z >= 0.0 && (compareMeta(uMetaBuffer[mid-1],z,tilex,tiley) != 0.0)) {
          if (min > max) {
            z--;
            min = 1;
            max = size;
            xoff = xoff/2.0 + mod(tilex, 2.0);
            yoff = yoff/2.0 + 1.0-mod(tiley, 2.0);
            tilex = floor(tilex/2.0);
            tiley = floor(tiley/2.0);
          }
          
          mid = (min + max) / 2;
          if (compareMeta(uMetaBuffer[mid-1],z,tilex,tiley) > 0.0) {
            max = mid - 1;
          } else {
            min = mid + 1;
          }
      }
      
      if (compareMeta(uMetaBuffer[mid-1],z,tilex,tiley) == 0.0) {
        float i = uMetaBuffer[mid-1].a;
        float reduction = pow(2.0,uZoomLevel - z);
        vTextureCoord.x = ((mod(i, uTileBufferSize.x)) + xoff/2.0  + (aTextureCoord.x)/reduction)/uTileBufferSize.x;
        vTextureCoord.y = ((floor(i / uTileBufferSize.x)) + yoff/2.0 + (aTextureCoord.y)/reduction)/uTileBufferSize.y;
        return;
      }
      
      vTextureCoord = vec2(0.0,0.0);//aTextureCoord;
      
      if ((abs(phiy) - MAX_PHI) > 0.01)
        vTextureCoord=vec2(0.5,0.5); //DEBUG
    }
  </script>
 </head> 
 <body onload="javascript:we.init(document.getElementById('glcanvas'));">
   <div id="fpsbox"></div><div id="coordbox"></div>
   <div id="tileprovider">Select TileProvider: </div>
   <canvas id="glcanvas" width="640" height="480">
    Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
   </canvas>
   <div id="log" style="float:right;"></div>
 </body> 
</html>