<?xml version='1.0' encoding='UTF-8'?> 
<!DOCTYPE HTML> 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
 <head> 
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> 
  <meta name="robots" content="index, all" />
  <meta name="author" content="Petr Sloup" />
  <title>WebGL Earth - compiled</title>
  
  <style>
    .goog-slider-horizontal {
      background-color: ThreeDFace;
      position: relative;
      overflow: hidden;
    }
 
    .goog-slider-thumb {
      position: absolute;
      background-color: ThreeDShadow;
      overflow: hidden;
    }
 
    .goog-slider-horizontal .goog-slider-thumb {
      left: 0;
      width: 20px;
      height: 100%;
    }
  </style>
  <script src="compiled.js"></script>
  
  <script id="shader-fs" type="x-shader/x-fragment"> 
    #ifdef GL_ES
    precision highp float;
    #endif
    
    //const float PI = 3.1415926535;
    //const float MAX_PHI = 1.4844222297453;
    varying vec2 vTextureCoord;
    
    uniform sampler2D uSampler;
    
    void main(void) {
      //float phi = PI*(vTextureCoord.t-0.5); //phi: -PI/2 -> PI/2
                                            //uhel, pro ktery chci vypocitat barvu
      //gl_FragColor = texture2D(uSampler,
      //  vec2(vTextureCoord.s, clamp((log(tan(phi/2.0 + PI/4.0))/PI)/2.0 + 0.5,0.0,1.0))
      //);
      //if (distance(vCoord,vec2(POINTX,POINTY)) < (1.567889621e+1/3.0))
      //{
      //  gl_FragColor = vec4(0.0,0.0,1.0,1.0);
      /*} else */if (min(vTextureCoord.x,vTextureCoord.y) < 4.0/256.0)
      {
        gl_FragColor = vec4(0.0,0.0,0.0,1.0); //BORDER
      } else {
      //  discard;
        //gl_FragColor = vec4(0.0,0.0,0.0,0.0); //vec4(vTextureCoord.x,vTextureCoord.y,0.0,1.0);
      //}
        gl_FragColor = mix(vec4(vTextureCoord.x,vTextureCoord.y,0.0,1.0),texture2D(uSampler, vTextureCoord),0.6); //texture2D(uSampler, vTextureCoord);//vec4(vTextureCoord.x,vTextureCoord.y,vTextureCoord.z,1.0); //vec4(0.0,0.0,0.0,1.0);
      }
    }
  </script>
   
  <script id="shader-vs" type="x-shader/x-vertex">
    const float PI  = 3.1415927;
    const float PI2 = 6.2831855;
    const float PIhalf = 1.5707963;
    const float MAX_PHI = 1.4844222;
    
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;
    
    uniform mat4 uMVPMatrix;
    
    uniform float uZoomLevel;
    uniform float uTileCount;
    //uniform float uLatitude;
    uniform float uYOffset;
    uniform float uXOffset;
        
    uniform sampler2D uSampler;
    
    varying vec2 vTextureCoord;
    //varying vec2 vCoord;
    
    void main(void) {      
      //souradnice vrcholu, ktery kreslim
      float phix = (aVertexPosition.x)/uTileCount*PI2; //(-PI;PI)
      float phiy = /*log(tan(uLatitude/2.0 + PI/4.0)) +*/ (uYOffset+aVertexPosition.y)/uTileCount*PI2; //(-PI;PI)
      
      //this version has better accuracy than 2.0*atan(exp(uLatitude + phiy)) - PI/2.0
      // (is more numerically stable)
      phiy = atan((exp(phiy) - exp(-phiy))/2.0);
      
      if (max(abs(phix),abs(phiy)) > PI) return;
      
      vec3 pos;// = aVertexPosition;
      pos.x = sin(phix)*cos(phiy);
      pos.y = sin(phiy);
      pos.z = (cos(abs(phix)))*cos(abs(phiy));
      gl_Position = uMVPMatrix * vec4(pos, 1.0);
      vTextureCoord = aTextureCoord; //aVertexPosition.x/4.0,aVertexPosition.y/4.0,0.0); //vec2(aTextureCoord.x*aTextureCoord.y,pos.z);//aTextureCoord;
      //vCoord = vec2(uXOffset+aVertexPosition.x-aTextureCoord.x,-(uYOffset+aVertexPosition.y-aTextureCoord.y));
      //TODO: vCoord (vse) se musi pocitat z uhlu, aVertexPosition.xy nereflektuje zatoceni bodu kolem dokola cele koule..
      //      vCoord se nemusi posilat do fragmentu, tam se budou posilat uz primo koordinaty
      //if (max(abs(pos.x),abs(pos.y)) > n/2.0)
      //  vTextureCoord=vec3(1.0,1.0,aTextureCoord.x); //DEBUG
      //TODO: vypocet texturovych coordinatu podle phix, phiy:
      //        prepocet phi.xy na tile.xy
      //        odecet vTextureCoord.xy (aby cely ctverecek mel stejny tile)
      //        lookup tilu v texture
      if ((abs(phiy) - MAX_PHI) > 0.01)
        vTextureCoord=vec2(0.0,0.0); //DEBUG
    }
  </script>
 </head> 
 <body onload="javascript:we.init(document.getElementById('glcanvas'));">
   <div id="fpsbox"></div>
   <canvas id="glcanvas" width="640" height="480">
    Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
   </canvas>
   <div id="log" style="float:right;"></div>
 </body> 
</html>